//
// Copyright (C) 2005 United States Government as represented by the
// Administrator of the National Aeronautics and Space Administration
// (NASA).  All Rights Reserved.
// 
// This software is distributed under the NASA Open Source Agreement
// (NOSA), version 1.3.  The NOSA has been approved by the Open Source
// Initiative.  See the file NOSA.txt at the top of the distribution
// directory tree for the complete NOSA document.
// 
// THE SUBJECT SOFTWARE IS PROVIDED "AS IS" WITHOUT ANY WARRANTY OF ANY
// KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY, INCLUDING, BUT NOT
// LIMITED TO, ANY WARRANTY THAT THE SUBJECT SOFTWARE WILL CONFORM TO
// SPECIFICATIONS, ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR
// A PARTICULAR PURPOSE, OR FREEDOM FROM INFRINGEMENT, ANY WARRANTY THAT
// THE SUBJECT SOFTWARE WILL BE ERROR FREE, OR ANY WARRANTY THAT
// DOCUMENTATION, IF PROVIDED, WILL CONFORM TO THE SUBJECT SOFTWARE.
//
//  Created by Al Globus on Mon Jul 08 2002.
package gov.nasa.javaGenes.EOSscheduling;

import gov.nasa.alsUtility.Error;
import gov.nasa.alsUtility.FieldRecordText;
import java.util.Vector;
import java.util.Date;
import gov.nasa.alsUtility.Utility;

// Files are generated by STK's AER capability
// STK puts out blank lines when a target never sees a sensor so STKAccessFile.java can deal with this.
public class STKAccessFile implements java.io.Serializable {
protected Horizon horizon;
protected FieldRecordText reader;
protected int timeBetweenSamples;

public STKAccessFile(String filename, int inTimeBetweenSamples) {
    timeBetweenSamples = inTimeBetweenSamples;
    Error.assertTrue(timeBetweenSamples > 0);

    // get horizon from first two lines
    reader = new FieldRecordText(filename);
    String line[] = reader.readLine();
    Error.assertTrue(line.length == 2);
    Error.assertTrue(line[0].equals("\"Start\""));
    Error.assertTrue(line[1].equals("\"Stop\""));
    line = reader.readLine();
    Error.assertTrue(line.length == 2);
    setHorizon(new Horizon(line[0],line[1]));
}
public int getCurrentLineNumber() {return reader.getCurrentLineNumber();}
public String getFilename() {return reader.getFilename();}
public Horizon getHorizon() {return horizon;}
public void setHorizon(Horizon inHorizon) {
    Error.assertNotNull(inHorizon);
    if (horizon != null)
        Error.assertTrue(inHorizon.includes(horizon));
    horizon = inHorizon;
}

/**
@return the access windows for a task or null if no more tasks. 
*/
public AccessWindow[] readaTask() {
    // read header for horizon information
    String line[] = reader.readLine();
    if (line == null)
            return null;

    if (line.length == 4) {
        Error.assertTrue(line[0].equals("\"Time (UTCG)\""));
        Error.assertTrue(line[1].equals("\"Azimuth (deg)\""));
        Error.assertTrue(line[2].equals("\"Elevation (deg)\""));
        Error.assertTrue(line[3].equals("\"Range (km)\""));
    } else // no contact for this task
        return new AccessWindow[0];

    // get access windows including slewing information
    Vector accesses = new Vector();
    while (true) {
        line = reader.readLine();
        if (line == null )
            Error.fatal("No blank line at end of file " 
                        + getFilename() 
                        + " line " 
                        + getCurrentLineNumber());
        if (line.length == 0)
            break;
        Error.assertTrue(line.length == 4);
        accesses.addElement(line);
    }
    if (accesses.size() < 2)
        return new AccessWindow[0];

    Vector windows = new Vector();
    AccessWindow w = new AccessWindow();
    String[] first = (String[])accesses.elementAt(0);
    w.setStart(getTime(first));
    addPointingRequirement(w,getTime(first),first);
    for(int i = 1; i < accesses.size(); i++) {
        String[] current = (String[])accesses.elementAt(i);
        String[] last = (String[])accesses.elementAt(i-1);
        int currentTime = getTime(current);
        int lastTime = getTime(last);
        if (currentTime - lastTime > timeBetweenSamples) {
            w.setEnd(lastTime);
            windows.addElement(w);
            w = new AccessWindow();
            w.setStart(currentTime);
        }
        addPointingRequirement(w,currentTime,current);
        if (i == accesses.size()-1) {
            w.setEnd(currentTime);
            if (windows.size() == 0 || w != (AccessWindow)windows.lastElement())
                windows.addElement(w);
            break;
        } 
    }
    AccessWindow[] array = new AccessWindow[windows.size()];
    windows.copyInto(array);
    return array;
}
protected int getTime(String[] lineFromStkAccessFile) {
    String time = lineFromStkAccessFile[0];
    Date date = Utility.stkDateString2Date(time);
    return horizon.getIntegerTimeAt(date);
}
// NOTE: no unit test
protected void addPointingRequirement(AccessWindow w, int time, String[] lineFromStkAccessFile) {
    double azimuth = Utility.string2double(lineFromStkAccessFile[1]);
    double elevation = Utility.string2double(lineFromStkAccessFile[2]);
    double range = Utility.string2double(lineFromStkAccessFile[3]);
    w.addPointingRequirement(new PointingRequirement(time,azimuth,elevation,range));
}
}
